"""
Vulnerability management service
"""
from typing import List, Optional, Dict, Any
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_
from loguru import logger

from app.models import Vulnerability, Asset
from app.models.enums import VulnerabilityState, VulnerabilitySeverity
from app.schemas.vulnerability import (
    VulnerabilityUpdate,
    VulnerabilityStateChange,
    VulnerabilityStats,
)


class VulnerabilityService:
    """Service for managing vulnerabilities"""

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_vulnerability(self, vuln_id: int) -> Optional[Vulnerability]:
        """Get vulnerability by ID"""
        return await self.db.get(Vulnerability, vuln_id)

    async def get_vulnerabilities(
        self,
        tenant_id: Optional[str] = None,
        skip: int = 0,
        limit: int = 100,
        state: Optional[VulnerabilityState] = None,
        severity: Optional[VulnerabilitySeverity] = None,
        asset_id: Optional[int] = None,
        scan_id: Optional[int] = None,
    ) -> List[Vulnerability]:
        """
        Get list of vulnerabilities with filters

        Args:
            tenant_id: Filter by tenant
            skip: Pagination offset
            limit: Pagination limit
            state: Filter by state
            severity: Filter by severity
            asset_id: Filter by asset
            scan_id: Filter by scan

        Returns:
            List of Vulnerability objects
        """
        stmt = select(Vulnerability)

        # Apply filters
        filters = []
        if tenant_id:
            filters.append(Vulnerability.tenant_id == tenant_id)
        if state:
            filters.append(Vulnerability.state == state.value)
        if severity:
            filters.append(Vulnerability.severity == severity.value)
        if asset_id:
            filters.append(Vulnerability.asset_id == asset_id)
        if scan_id:
            filters.append(Vulnerability.scan_id == scan_id)

        if filters:
            stmt = stmt.where(and_(*filters))

        stmt = stmt.offset(skip).limit(limit).order_by(Vulnerability.created_at.desc())

        result = await self.db.execute(stmt)
        return list(result.scalars().all())

    async def update_vulnerability(
        self,
        vuln_id: int,
        vuln_update: VulnerabilityUpdate,
    ) -> Vulnerability:
        """
        Update a vulnerability

        Args:
            vuln_id: Vulnerability ID
            vuln_update: Update data

        Returns:
            Updated Vulnerability object
        """
        vuln = await self.db.get(Vulnerability, vuln_id)
        if not vuln:
            raise ValueError(f"Vulnerability {vuln_id} not found")

        # Update fields
        update_data = vuln_update.model_dump(exclude_unset=True)

        # Handle enum fields
        if "state" in update_data:
            update_data["state"] = update_data["state"].value

        for field, value in update_data.items():
            setattr(vuln, field, value)

        await self.db.commit()
        await self.db.refresh(vuln)

        logger.info(f"Updated vulnerability {vuln.id}")

        return vuln

    async def change_state(
        self,
        vuln_id: int,
        state_change: VulnerabilityStateChange,
        user_id: Optional[int] = None,
    ) -> Vulnerability:
        """
        Change vulnerability state

        Args:
            vuln_id: Vulnerability ID
            state_change: State change data
            user_id: User making the change

        Returns:
            Updated Vulnerability object
        """
        vuln = await self.db.get(Vulnerability, vuln_id)
        if not vuln:
            raise ValueError(f"Vulnerability {vuln_id} not found")

        old_state = vuln.state
        new_state = state_change.state.value

        vuln.state = new_state
        vuln.state_changed_at = datetime.utcnow().isoformat()
        vuln.state_changed_by_user_id = user_id

        # If resolving, set resolution details
        if new_state in [
            VulnerabilityState.RESOLVED.value,
            VulnerabilityState.FALSE_POSITIVE.value,
        ]:
            vuln.resolved_at = datetime.utcnow().isoformat()
            vuln.resolved_by_user_id = user_id
            if state_change.notes:
                vuln.resolution_notes = state_change.notes

        await self.db.commit()
        await self.db.refresh(vuln)

        logger.info(f"Changed vulnerability {vuln.id} state from {old_state} to {new_state}")

        return vuln

    async def assign_vulnerability(
        self,
        vuln_id: int,
        assigned_to_user_id: int,
    ) -> Vulnerability:
        """
        Assign vulnerability to a user

        Args:
            vuln_id: Vulnerability ID
            assigned_to_user_id: User ID to assign to

        Returns:
            Updated Vulnerability object
        """
        vuln = await self.db.get(Vulnerability, vuln_id)
        if not vuln:
            raise ValueError(f"Vulnerability {vuln_id} not found")

        vuln.assigned_to_user_id = assigned_to_user_id
        vuln.assigned_at = datetime.utcnow().isoformat()

        await self.db.commit()
        await self.db.refresh(vuln)

        logger.info(f"Assigned vulnerability {vuln.id} to user {assigned_to_user_id}")

        return vuln

    async def accept_risk(
        self,
        vuln_id: int,
        reason: str,
        user_id: Optional[int] = None,
    ) -> Vulnerability:
        """
        Accept risk for a vulnerability

        Args:
            vuln_id: Vulnerability ID
            reason: Reason for risk acceptance
            user_id: User accepting the risk

        Returns:
            Updated Vulnerability object
        """
        vuln = await self.db.get(Vulnerability, vuln_id)
        if not vuln:
            raise ValueError(f"Vulnerability {vuln_id} not found")

        vuln.is_risk_accepted = True
        vuln.risk_acceptance_reason = reason
        vuln.risk_accepted_by_user_id = user_id
        vuln.risk_accepted_at = datetime.utcnow().isoformat()
        vuln.state = VulnerabilityState.ACCEPTED_RISK.value
        vuln.state_changed_at = datetime.utcnow().isoformat()
        vuln.state_changed_by_user_id = user_id

        await self.db.commit()
        await self.db.refresh(vuln)

        logger.info(f"Accepted risk for vulnerability {vuln.id}")

        return vuln

    async def get_stats(
        self,
        tenant_id: Optional[str] = None,
        asset_id: Optional[int] = None,
    ) -> VulnerabilityStats:
        """
        Get vulnerability statistics

        Args:
            tenant_id: Filter by tenant
            asset_id: Filter by asset

        Returns:
            VulnerabilityStats object
        """
        filters = []
        if tenant_id:
            filters.append(Vulnerability.tenant_id == tenant_id)
        if asset_id:
            filters.append(Vulnerability.asset_id == asset_id)

        # Total count
        stmt = select(func.count(Vulnerability.id))
        if filters:
            stmt = stmt.where(and_(*filters))
        result = await self.db.execute(stmt)
        total = result.scalar() or 0

        # Count by severity
        stmt = select(
            Vulnerability.severity,
            func.count(Vulnerability.id)
        )
        if filters:
            stmt = stmt.where(and_(*filters))
        stmt = stmt.group_by(Vulnerability.severity)

        result = await self.db.execute(stmt)
        by_severity = {row[0]: row[1] for row in result}

        # Count by state
        stmt = select(
            Vulnerability.state,
            func.count(Vulnerability.id)
        )
        if filters:
            stmt = stmt.where(and_(*filters))
        stmt = stmt.group_by(Vulnerability.state)

        result = await self.db.execute(stmt)
        by_state = {row[0]: row[1] for row in result}

        # Count by asset (if not filtering by asset)
        by_asset = {}
        if not asset_id:
            stmt = select(
                Vulnerability.asset_id,
                func.count(Vulnerability.id)
            )
            if tenant_id:
                stmt = stmt.where(Vulnerability.tenant_id == tenant_id)
            stmt = stmt.group_by(Vulnerability.asset_id)

            result = await self.db.execute(stmt)
            by_asset = {row[0]: row[1] for row in result}

        # Open and resolved counts
        open_states = [
            VulnerabilityState.NEW.value,
            VulnerabilityState.TRIAGING.value,
            VulnerabilityState.INVESTIGATING.value,
            VulnerabilityState.REMEDIATION.value,
        ]

        stmt = select(func.count(Vulnerability.id)).where(
            Vulnerability.state.in_(open_states)
        )
        if filters:
            stmt = stmt.where(and_(*filters))
        result = await self.db.execute(stmt)
        open_count = result.scalar() or 0

        resolved_count = by_state.get(VulnerabilityState.RESOLVED.value, 0)

        return VulnerabilityStats(
            total=total,
            by_severity=by_severity,
            by_state=by_state,
            by_asset=by_asset,
            open_count=open_count,
            resolved_count=resolved_count,
        )

    async def delete_vulnerability(self, vuln_id: int) -> bool:
        """
        Delete a vulnerability

        Args:
            vuln_id: Vulnerability ID

        Returns:
            True if deleted, False if not found
        """
        vuln = await self.db.get(Vulnerability, vuln_id)
        if not vuln:
            return False

        await self.db.delete(vuln)
        await self.db.commit()

        logger.info(f"Deleted vulnerability {vuln.id}")

        return True


def get_vulnerability_service(db: AsyncSession) -> VulnerabilityService:
    """Get vulnerability service instance"""
    return VulnerabilityService(db)
