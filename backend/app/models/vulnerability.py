"""
Vulnerability model for scan findings
"""
from sqlalchemy import Column, Integer, String, Boolean, JSON, ForeignKey, Text, Index
from sqlalchemy.orm import relationship
from app.core.database import Base
from app.models.base import TimestampMixin, TenantMixin
from app.models.enums import VulnerabilityState, VulnerabilitySeverity


class Vulnerability(Base, TimestampMixin, TenantMixin):
    """
    Vulnerability finding from Nuclei scans
    """
    __tablename__ = "vulnerabilities"

    id = Column(Integer, primary_key=True, index=True)

    # Reference to asset and scan
    asset_id = Column(Integer, ForeignKey("assets.id", ondelete="CASCADE"), nullable=False, index=True)
    scan_id = Column(Integer, ForeignKey("scans.id", ondelete="CASCADE"), nullable=False, index=True)

    # Nuclei template information
    template_id = Column(String(255), nullable=False, index=True)  # Nuclei template ID
    template_name = Column(String(500))
    template_path = Column(String(500))

    # Vulnerability details
    name = Column(String(500), nullable=False)
    description = Column(Text)
    severity = Column(String(50), nullable=False, index=True)  # VulnerabilitySeverity enum

    # Target details
    matched_at = Column(String(1000), nullable=False)  # URL/endpoint where found
    extracted_results = Column(JSON, default=[])  # Extracted data from template

    # Request/Response (for debugging)
    request = Column(Text)  # HTTP request
    response = Column(Text)  # HTTP response
    curl_command = Column(Text)  # cURL command to reproduce

    # Classification
    tags = Column(JSON, default=[])  # CVE tags, CWE tags, etc.
    cve_ids = Column(JSON, default=[])  # CVE identifiers
    cwe_ids = Column(JSON, default=[])  # CWE identifiers
    cvss_score = Column(String(10))  # CVSS score if available

    # Metadata from Nuclei
    template_metadata = Column(JSON, default={})  # Additional metadata from template
    reference_urls = Column(JSON, default=[])  # Reference URLs

    # Workflow state
    state = Column(String(50), default=VulnerabilityState.NEW.value, nullable=False, index=True)
    state_changed_at = Column(String(50))  # ISO date when state last changed
    state_changed_by_user_id = Column(Integer, ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    # Assignment
    assigned_to_user_id = Column(Integer, ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    assigned_at = Column(String(50))

    # Resolution
    resolution_notes = Column(Text)  # Notes about resolution/false positive
    resolved_at = Column(String(50))
    resolved_by_user_id = Column(Integer, ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    # Deduplication
    hash = Column(String(64), index=True)  # Hash for deduplication (template_id + matched_at)
    first_seen_at = Column(String(50))  # First time this vulnerability was seen
    last_seen_at = Column(String(50))  # Last time this vulnerability was seen
    occurrences = Column(Integer, default=1)  # How many times it's been found

    # Risk acceptance
    is_risk_accepted = Column(Boolean, default=False)
    risk_acceptance_reason = Column(Text)
    risk_accepted_by_user_id = Column(Integer, ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    risk_accepted_at = Column(String(50))

    # Relationships
    asset = relationship("Asset", back_populates="vulnerabilities")
    scan = relationship("Scan", back_populates="vulnerabilities")
    state_changed_by = relationship("User", foreign_keys=[state_changed_by_user_id])
    assigned_to = relationship("User", foreign_keys=[assigned_to_user_id])
    resolved_by = relationship("User", foreign_keys=[resolved_by_user_id])
    risk_accepted_by = relationship("User", foreign_keys=[risk_accepted_by_user_id])

    # Indexes for common queries
    __table_args__ = (
        Index('ix_vulnerabilities_asset_state', 'asset_id', 'state'),
        Index('ix_vulnerabilities_severity_state', 'severity', 'state'),
        Index('ix_vulnerabilities_tenant_state', 'tenant_id', 'state'),
    )

    def __repr__(self):
        return f"<Vulnerability {self.template_id} on {self.matched_at}>"

    @property
    def is_open(self) -> bool:
        """Check if vulnerability is still open"""
        return self.state not in [
            VulnerabilityState.RESOLVED.value,
            VulnerabilityState.FALSE_POSITIVE.value,
            VulnerabilityState.ACCEPTED_RISK.value
        ]
